#!/usr/bin/perl
BEGIN { if (grep {/--debug/} @ARGV) { my @ARGS=grep {!/--debug/} @ARGV; exec($^X, "-d", __FILE__, @ARGS); } }
# system('env | grep -E "(CUDA|LLAMA|LD_|PATH)" > /tmp/script_env.txt');
# exit;
use v5.36;
use JSON::XS;
use File::Find;
use File::Path qw(make_path);
use File::Copy;
use File::Basename;
use Digest::MD5 qw(md5_hex);
use Time::Piece;
use Fcntl qw(:flock);
no warnings 'once';
use Text::Table;
use utf8;
binmode(STDOUT, "encoding(utf8)");
binmode(STDERR, "encoding(utf8)");

my $progname = 'llama-pack';

my $def_port = 8080;
my $def_host = '127.0.0.1';
my $config_dir = $ENV{HOME} . "/.config/$progname";
my $config_file = "$config_dir/config.json";
my $editor = $ENV{EDITOR} // 'vim';

# bansi color exports
our ($bgbla, $bgred, $bggre, $bgbro, $bgblu, $bgmag, $bgcya, $bggra);
our ($bla, $red, $gre, $bro, $blu, $mag, $cya, $gra);
our ($bbla, $bred, $bgre, $yel, $bblu, $bmag, $bcya, $whi);
our ($rst, $inv, $cll, $cllr, $cls, $clsb, $ahome);

init_colors();

our $verbose = $ENV{LLAMA_SERVE_VERBOSE} // 0;
our $stats_dirty = 0;
our $current_runtime_start;
our $stats;  # Global stats hash - loaded once, modified in memory, written on exit

use v5.36; # nice
sub se; sub sel; sub pe; sub pel; # Keep for use w/o ()
sub pe { print STDERR @_; }
sub pel { my $l=shift; print STDERR @_ if $verbose >= $l; }
sub se { say STDERR @_; }
sub sel { my $l=shift; say STDERR @_ if $verbose >= $l; }

END {
    write_stats() if $stats_dirty;
}

$SIG{INT} = $SIG{TERM} = sub {
    update_current_runtime() if $current_runtime_start;
    $stats_dirty = 1;
    exit 0;
};

main();

sub main {
    # Parse our args vs llama-server args
    my ($opts, $llama_args) = parse_args();

    # Handle commands that don't need config loaded
    if ($opts->{edit_config}) { edit_config(); exit }

    my $config = load_config();
    # Apply config defaults if not specified on command line
    $opts->{port} //= $config->{default_port} // $def_port;
    $opts->{host} //= $config->{default_host} // $def_host;

    # Add host/port to llama_args if they weren't already added
    my $has_port = grep { $_ eq '--port' } @$llama_args;
    my $has_host = grep { $_ eq '--host' } @$llama_args;

    push @$llama_args, '--port', $opts->{port} unless $has_port;
    push @$llama_args, '--host', $opts->{host} unless $has_host;

    # Handle commands that don't need model loading
    if ($opts->{edit_config}) {
    	edit_config();
        exit 0;
    }

    if ($opts->{list}) {
        list_models($config);
        exit 0;
    }

    if ($opts->{status}) {
        show_status($config);
        exit 0;
    }

    if ($opts->{update}) {
        scan_models($config);
        say "${gre}Model index updated.$rst";
        exit 0;
    }

    if ($opts->{simulate}) {
        run_simulation($config, $opts);
        exit 0;
    }

    # If -k without model, just kill
    if ($opts->{kill} && !$opts->{model}) {
        kill_instances($config, $opts);
        exit 0;
    }

    # If -k WITH model, kill first then continue to load model
    if ($opts->{kill} && $opts->{model}) {
        say "${yel}Killing existing server(s) before loading model...$rst" if $verbose;
        kill_instances($config, $opts);
    }

    # Need a model to proceed
    unless ($opts->{model}) {
        serr(0, "No model specified. Use -m or --model");
        exit 1;
    }

    # Auto-scan on first run if no stats file exists
    if (!-f $config->{stats_file}) {
        say "${yel}First run detected. Scanning for models...$rst";
        scan_models($config);
    }

    # Load stats ONCE into global
    $stats = load_stats($config);

    # Find the model (future: check nicknames first)
    my $model_info = find_model($config, $stats, $opts->{model});
    unless ($model_info) {
        serr(0, "Model '$$opts{model}' not found.");
        exit 1;
    }

    say "${gre}Found model: $$model_info{path}$rst" if $verbose;

    # Handle model-specific args
    my $model_key = basename($model_info->{path});
    $stats->{$model_key} //= {};
    my $mstats = $stats->{$model_key};

    # Determine which args to use
    my @final_llama_args;
    if (@$llama_args && (!$mstats->{llama_args} || $opts->{store})) {
        # First run with args, or explicit --store: save them
        $mstats->{llama_args} = $llama_args;
        @final_llama_args = @$llama_args;
        $stats_dirty = 1;
        say "${gre}Stored model-specific args.$rst" if $verbose;
    } elsif ($mstats->{llama_args}) {
        # Use stored args
        @final_llama_args = @{$mstats->{llama_args}};
        say "${gre}Using stored model-specific args.$rst" if $verbose;
        if (@$llama_args && !$opts->{store}) {
            say "${yel}Note: New args provided but not stored. Use --store to update.$rst";
        }
    } else {
        # No stored args, use what was provided (if any)
        @final_llama_args = @$llama_args;
    }

    # Prepend global args from config
    my @global_args = @{$config->{global_llama_args} // []};
    unshift @final_llama_args, @global_args;

    # Check if already running with same args
    my $pid_file = get_pid_file($config, $opts->{port});
    if (-f $pid_file) {
        my $running = read_pid_file($pid_file);
        if ($running && process_exists($running->{pid})) {
            my $args_hash = md5_hex(join('|', @final_llama_args));
            if ($running->{model} eq $model_info->{path} &&
                $running->{args_hash} eq $args_hash) {
                say "${gre}Model already running on host:port $$opts{host}:$$opts{port} with same args.$rst";
                exit 0;
            } else {
                say "${yel}Killing existing server to reload with different model/args...$rst";
                kill_pid($running->{pid});
                unlink $pid_file;
            }
        }
    }

    # Update stats for this model
    $mstats->{path} = $model_info->{path};
    $mstats->{total_uses} //= 0;
    $mstats->{total_uses}++;
    $mstats->{last_used} = gmtime->datetime;
    $mstats->{use_timestamps} //= [];
    push @{$mstats->{use_timestamps}}, gmtime->datetime;

    # Keep only last 100 timestamps to prevent bloat
    if (@{$mstats->{use_timestamps}} > 100) {
        $mstats->{use_timestamps} = [
            @{$mstats->{use_timestamps}}[-100..-1]
        ];
    }

    $stats_dirty = 1;

    # Should we cache to SSD?
    if ($model_info->{location} eq 'hdd' && should_cache_to_ssd($mstats)) {
        say "${yel}Model used multiple times recently. Caching to SSD...$rst";
        fork_ssd_copy($config, $model_info, $stats);
    }

    # Start llama-server
    start_server($config, $opts, $model_info, \@final_llama_args);
}

sub usage {
	print <<~EOT;
		$progname: Manage and load LLM models with smart SSD caching.

		RUNNING MODELS:
		  -m, --model NAME     Load model by name/pattern
		  -p, --port N         Server port (default: $def_port)
		  --host ADDR          Server host (default: $def_host, use 0.0.0.0 for all interfaces)
		  --store, --keep      Save model-specific args for future runs
		MANAGING MODELS:
		  -l, --list           List all models with stats and rankings
		  -u, --update         Scan directories and update model index
		  --status, --stat     Show currently running servers
		  --st
		  --ec --ce --edit-config  Edit, like: $editor config_file
		                       (Uses env var \$EDITOR)
		KILLING SERVERS:
		  -k, --kill           Kill server on specified port (use with -p/--port)
		  --killall, --kall    Kill ALL $progname managed servers
		SIMULATION:
		  --simulate NAME      Run named simulation preset from config
		  --simulate PATTERN   Run custom simulation pattern (contains = or ;)
		  --sim-ssd-free SIZE  Override SSD free space (e.g. 50g, 100m, 1.5g)
		OTHER:
		  -v, --verbose        Increase verbosity (use multiple times: -v -v)
		  -h, --help           This help
		  --                   Everything after this goes to llama-server

		EXAMPLES:
		  $progname -m mymodel                    # Load model with saved args
		  $progname -m mymodel -- -c 8192         # Override context size once
		  $progname -m mymodel --store -- -c 8192 # Save new context size
		  $progname -k -p 8080                    # Kill server on port 8080
		  $progname --killall                     # Kill all running servers
		  $progname --status                      # Show what's running
		  $progname --simulate daily_work         # Run simulation preset
		  $progname --simulate "test:10g=0s/1h,1d/2h" --sim-ssd-free 50g

		*Note: Simulation preset names may not contain = or ;

		CONFIG: $config_file
		EOT
}

sub parse_args {
    my %opts = (
        port => undef,
        host => undef,
        list => 0,
        update => 0,
        kill => 0,
        kill_all => 0,
        store => 0,
        status => 0,
        simulate => undef,
        sim_ssd_free => undef,
    );
    my @llama_args;
    my $in_llama_args = 0;

    while (@ARGV) {
        my $arg = shift @ARGV;

        # -- separator means everything after goes to llama-server
        if ($arg eq '--') {
            $in_llama_args = 1;
            next;
        }

        if ($in_llama_args) {
            push @llama_args, $arg;
            next;
        }

        if ($arg eq '-h' || $arg eq '--help') {
        	usage(); exit;
		} elsif ($arg eq '-m' || $arg eq '--model') {
            $opts{model} = shift @ARGV;
        } elsif ($arg eq '-l' || $arg eq '--list') {
            $opts{list} = 1;
        } elsif ($arg eq '-u' || $arg eq '--update') {
            $opts{update} = 1;
        } elsif ($arg eq '-k' || $arg eq '--kill') {
            $opts{kill} = 1;
        } elsif ($arg eq '--killall' || $arg eq '--kall') {
            $opts{kill_all} = 1;
            $opts{kill} = 1;
        } elsif ($arg eq '--status' || $arg eq '--stat' || $arg eq '--st') {
            $opts{status} = 1;
        } elsif ($arg eq '--simulate') {
            $opts{simulate} = shift @ARGV;
        } elsif ($arg eq '--sim-ssd-free') {
            $opts{sim_ssd_free} = shift @ARGV;
        } elsif ($arg eq '--host') {
            my $host = shift @ARGV;
            $opts{host} = $host;
        } elsif ($arg eq '-p' || $arg eq '--port') {
            my $port = shift @ARGV;
            $opts{port} = $port;
        } elsif ($arg eq '--store' || $arg eq '--keep') {
            $opts{store} = 1;
        } elsif ($arg eq '--ce' || $arg eq '--ec' || $arg eq '--edit-config') {
            $opts{edit_config} = 1;
        } elsif ($arg eq '-v' || $arg eq '--verbose') {
            $verbose++;
        } else {
            push @llama_args, $arg;
        }
    }

    return (\%opts, \@llama_args);
}

sub load_config {
    make_path($config_dir) unless -d $config_dir;

    if (-f $config_file) {
        open my $fh, '<', $config_file or die "Can't read config: $!";
        my $json = do { local $/; <$fh> };
        close $fh;

        # Remove // comments
        $json =~ s|//.*$||gm;

        my $config = decode_json($json);
        $config->{stats_file} = glob $config->{stats_file} if $config->{stats_file}//0;
        $config->{stats_file} //= "$config_dir/stats.json";
        $config->{hdd_path} = glob $config->{hdd_path} if $config->{hdd_path}//0;
        $config->{ssd_path} = glob $config->{ssd_path} if $config->{ssd_path}//0;
        $config->{pid_dir} = glob $config->{pid_dir} if $config->{pid_dir}//0;
        $config->{pid_dir} //= "/tmp/$progname";
        $config->{server_binary} = glob $config->{server_binary} if $config->{server_binary}//'llama-server';
        return $config;
    }

    # Create default config
    my $config = {
        ssd_path => "$ENV{HOME}/models/ssd",
        hdd_path => "$ENV{HOME}/models/hdd",
        ssd_min_free_gb => 30,
        server_binary => 'llama-server',
        default_port => $def_port,
        default_host => $def_host,
        stats_file => "$config_dir/stats.json",
        pid_dir => "/tmp/$progname",
        global_llama_args => [
            '--flash-attn',
            '-ngl', '80',
            '-c', '15000',
            '--jinja',
        ],
        simulations => {
            simple => {
                description => "Basic cache trigger test - 2 uses within 24h",
                pattern => "testmodel:10g=0s/5m,1h/5m,25h/5m",
                ssd_free_gb => 50,
            },
            daily_work => {
                description => "Realistic daily workflow with model switching",
                pattern => "llama:45g=0s/2h,1d/3h,2d/2h,3d/4h; qwen:30g=0s/30m,12h/1h,1d/30m,2d/1h; gemma:8g=2d/15m,3d/20m",
                ssd_free_gb => 100,
            },
            rapid_switch => {
                description => "Frequent switching between models",
                pattern => "coding:16g=0s/30m,1h/45m,2h/30m,3h/1h; chat:25g=30m/20m,90m/30m,150m/45m; tool:5g=45m/10m,2h/15m",
                ssd_free_gb => 80,
            },
            cache_pressure => {
                description => "Testing cache expiry with limited space",
                pattern => "big1:40g=0s/1h,2d/30m; big2:40g=1h/1h,3d/30m; big3:40g=2h/1h,4d/30m",
                ssd_free_gb => 60,
            },
        },
    };

    open my $fh, '>', $config_file or die "Can't write config: $!";
    my $json_text = JSON::XS->new->pretty->canonical->encode($config);

    # Add helpful comments
    my $commented = <<~EOT;
		{
		  // Paths to model directories
		  "ssd_path" : "~/models/ssd",
		  "hdd_path" : "~/models/hdd",

		  // Minimum free space to maintain on SSD (GB)
		  "ssd_min_free_gb" : 30,

		  // llama.cpp server binary name/path
		  "server_binary" : "llama-server",

		  // Default host for server (0.0.0.0 for all interfaces)
		  "default_host" : "127.0.0.1",

		  // Default port for server
		  "default_port" : 8080,

		  // Internal files
		  "stats_file" : "$config_dir/stats.json",
		  "pid_dir" : "/tmp/$progname",

		  // Global args passed to ALL models (customize these!)
		  "global_llama_args" : [
		    "--flash-attn",
		    "-ngl", "80",
		    "-c", "15000",
		    "--jinja",
		  ],

		  // Simulation presets (see --help for pattern format)
		  "simulations" : {
		    "simple" : {
		      "description" : "Basic cache trigger test - 2 uses within 24h",
		      "pattern" : "testmodel:10g=0s/5m,1h/5m,25h/5m",
		      "ssd_free_gb" : 50
		    },
		    "daily_work" : {
		      "description" : "Realistic daily workflow with model switching",
		      "pattern" : "llama:45g=0s/2h,1d/3h,2d/2h,3d/4h; qwen:30g=0s/30m,12h/1h,1d/30m,2d/1h; gemma:8g=2d/15m,3d/20m",
		      "ssd_free_gb" : 100
		    },
		    "rapid_switch" : {
		      "description" : "Frequent switching between models",
		      "pattern" : "coding:16g=0s/30m,1h/45m,2h/30m,3h/1h; chat:25g=30m/20m,90m/30m,150m/45m; tool:5g=45m/10m,2h/15m",
		      "ssd_free_gb" : 80
		    },
		    "cache_pressure" : {
		      "description" : "Testing cache expiry with limited space",
		      "pattern" : "big1:40g=0s/1h,2d/30m; big2:40g=1h/1h,3d/30m; big3:40g=2h/1h,4d/30m",
		      "ssd_free_gb" : 60
		    }
		  }
		}
		EOT

    $commented =~ s/\$HOME/$ENV{HOME}/g;
    $commented =~ s/\$config_dir/$config_dir/g;

    print $fh $commented;
    close $fh;

    say "${gre}Created default config at: $config_file$rst";
    say "${yel}Edit global_llama_args and paths to customize.$rst";

    return $config;
}

sub load_stats {
    my $config = shift;
    my $file = $config->{stats_file};

    return {} if !-f $file;

    open my $fh, '<', $file or return {};
    my $json = do { local $/; <$fh> };
    close $fh;
    if ($json !~ /\S/) {
    	return {}
	} else {
		return decode_json($json);
	}
}

sub write_stats {
    my $config = load_config();
    
    # Write the GLOBAL $stats that's been modified in memory
    open my $fh, '>', $config->{stats_file} or do {
        serr(0, "Can't write stats: $!");
        return;
    };

    print $fh JSON::XS->new->pretty->encode($stats);
    close $fh;

    $stats_dirty = 0;
}

sub scan_models {
    my $config = shift;
    
    # Load into global if not already loaded
    $stats //= load_stats($config);

    # Clear existing locations to rescan
    for my $key (keys %$stats) {
        $stats->{$key}{locations} = [];
    }

    for my $location (qw(ssd hdd)) {
        my $path = $config->{"${location}_path"};
        next unless -d $path;

        find(sub {
            return unless -f && /\.gguf$/i;
            my $full_path = $File::Find::name;
            say "$full_path" if $verbose;
            my $key = basename($full_path);

            $stats->{$key} //= {};
            $stats->{$key}{locations} //= [];

            # Only add if not already present
            push @{$stats->{$key}{locations}}, $location
                unless grep { $_ eq $location } @{$stats->{$key}{locations}};

            # Update path to prefer SSD
            if ($location eq 'ssd' || !$stats->{$key}{path}) {
                $stats->{$key}{path} = $full_path;
            }

            $stats->{$key}{size_bytes} = -s $full_path;
            $stats->{$key}{mtime} = (stat($full_path))[9];

        }, $path);
    }

    # Write updated stats
    open my $fh, '>', $config->{stats_file} or die "Can't write stats ($config->{stats_file}): $!";
    print $fh JSON::XS->new->pretty->encode($stats);
    close $fh;
}

sub find_model {
    my ($config, $stats, $model_name) = @_;

    # Future: check nicknames here first
    # if (my $nick_model = lookup_nickname($stats, $model_name)) {
    #     return $nick_model;
    # }

    # Calculate mtime range for ranking
    my ($newest_mtime, $oldest_mtime) = (0, time);
    for my $model (keys %$stats) {
        my $mtime = $stats->{$model}{mtime} // 0;
        $newest_mtime = $mtime if $mtime > $newest_mtime;
        $oldest_mtime = $mtime if $mtime < $oldest_mtime && $mtime > 0;
    }

    # Try exact match first
    if ($stats->{$model_name}) {
        my $locs = $stats->{$model_name}{locations} // [];
        my $preferred = (grep { $_ eq 'ssd' } @$locs) ? 'ssd' : $locs->[0] // 'unknown';
        return {
            path => $stats->{$model_name}{path},
            location => $preferred,
            locations => $locs,
        };
    }

    # Try substring match
    my @matches;
    for my $key (keys %$stats) {
        push @matches, $key if $key =~ /\Q$model_name\E/i;
    }

    if (@matches == 0) {
        return undef;
    } elsif (@matches == 1) {
        my $key = $matches[0];
        my $locs = $stats->{$key}{locations} // [];
        my $preferred = (grep { $_ eq 'ssd' } @$locs) ? 'ssd' : $locs->[0] // 'unknown';
        return {
            path => $stats->{$key}{path},
            location => $preferred,
            locations => $locs,
        };
    } else {
        # Multiple matches - pick highest ranked
        say "${yel}Multiple models found matching '$model_name':$rst";
        my @ranked = sort {
            rank_model($stats->{$b}, $newest_mtime, $oldest_mtime) <=>
            rank_model($stats->{$a}, $newest_mtime, $oldest_mtime)
        } @matches;

        for my $m (@ranked) {
            my $rank = sprintf("%.1f", rank_model($stats->{$m}, $newest_mtime, $oldest_mtime));
            say "  $m (rank: $rank)";
        }

        my $chosen = $ranked[-1];  # Highest rank is at end now
        say "${gre}Using highest-ranked: $chosen$rst";

        my $locs = $stats->{$chosen}{locations} // [];
        my $preferred = (grep { $_ eq 'ssd' } @$locs) ? 'ssd' : $locs->[0] // 'unknown';
        return {
            path => $stats->{$chosen}{path},
            location => $preferred,
            locations => $locs,
        };
    }
}

sub rank_model {
    my ($mstats, $newest_mtime, $oldest_mtime) = @_;

    my $total_uses = $mstats->{total_uses} // 0;
    my $last_used = $mstats->{last_used};
    my $days_since = $last_used ? days_ago($last_used) : 999;

    # File mtime bonus: normalize file age to 0-1 range, scale to small bonus
    my $mtime_bonus = 0;
    if ($mstats->{mtime} && $newest_mtime && $oldest_mtime && $newest_mtime != $oldest_mtime) {
        # Newer files get higher bonus (0 to 0.5 points)
        my $normalized = ($mstats->{mtime} - $oldest_mtime) / ($newest_mtime - $oldest_mtime);
        $mtime_bonus = $normalized * 0.5;
    }

    # Simple ranking: recent use matters most, slight nudge for new files
    return $total_uses - ($days_since * 2) + $mtime_bonus;
}

sub days_ago {
    my $timestamp = shift;
    return 999 unless $timestamp;

    my $then = eval { Time::Piece->strptime($timestamp, '%Y-%m-%dT%H:%M:%S') };
    return 999 unless $then;

    my $diff = time - $then->epoch;
    return $diff / 86400;
}

sub should_cache_to_ssd {
    my $mstats = shift;
    my $timestamps = $mstats->{use_timestamps} // [];

    my $count = 0;
    for my $ts (@$timestamps) {
        $count++ if days_ago($ts) < 7;
    }

    return $count >= 2;
}

sub fork_ssd_copy {
    my ($config, $model_info, $stats) = @_;

    my $pid = fork();
    if ($pid == 0) {
        # Child process
        my $src = $model_info->{path};
        my $dst = $config->{ssd_path} . '/' . basename($src);

        say "${blu}[Background] Copying to SSD: $src -> $dst$rst" if $verbose;

        copy($src, $dst) or do {
            serr(0, "[Background] Copy failed: $!");
            exit 1;
        };

        say "${gre}[Background] Copy complete.$rst" if $verbose;
        exit 0;
    }
    # Parent continues
}

sub start_server {
    my ($config, $opts, $model_info, $llama_args) = @_;

    my $binary = $config->{server_binary};
    my @cmd = ($binary, '-m', $model_info->{path}, @$llama_args);

    se "${gre}Starting: $rst" . join(' ', @cmd);

    # Write PID file BEFORE forking so we have the file reference
    my $pid_file = get_pid_file($config, $opts->{port});

    # Fork server
    my $pid = fork();
    die "Fork failed: $!" unless defined $pid;

    if ($pid == 0) {
        # Child - exec server
        exec(@cmd) or die "Exec failed: $!";
    }

    # Parent - write PID file with child's PID and wait
    $current_runtime_start = time;
    my $model_key = basename($model_info->{path});
    write_pid_file($config, $opts->{port}, $pid, $model_info->{path}, $llama_args);

    say "${gre}Server started (PID: $pid, Host:Port: $$opts{host}:$$opts{port})$rst";
    say "${gre}PID file: $pid_file$rst" if $verbose;

    # Wait for server - when it exits, update runtime stats
    waitpid($pid, 0);
    my $exit_status = $? >> 8;

    say "${yel}Server exited with status: $exit_status$rst" if $verbose;

    # Update runtime stats in global $stats
    my $runtime_seconds = time - $current_runtime_start;

    if ($stats->{$model_key}) {
        $stats->{$model_key}{total_runtime_seconds} //= 0;
        $stats->{$model_key}{total_runtime_seconds} += $runtime_seconds;
        $stats->{$model_key}{last_runtime_seconds} = $runtime_seconds;
        $stats_dirty = 1;
        
        say "${gre}Runtime logged: ${runtime_seconds}s$rst" if $verbose;
    }

    # Clean up PID file on exit
    unlink $pid_file if -f $pid_file;
}

sub get_pid_file {
    my ($config, $port) = @_;
    my $dir = $config->{pid_dir};
    make_path($dir) unless -d $dir;
    return "$dir/port-$port.pid";
}

sub write_pid_file {
    my ($config, $port, $pid, $model, $llama_args) = @_;

    my $file = get_pid_file($config, $port);
    my $args_hash = md5_hex(join('|', @$llama_args));

    open my $fh, '>', $file or die "Can't write PID file: $!";
    print $fh "$pid|$port|$model|$args_hash\n";
    close $fh;
}

sub read_pid_file {
    my $file = shift;

    open my $fh, '<', $file or return undef;
    my $line = <$fh>;
    close $fh;

    chomp $line;
    my ($pid, $port, $model, $args_hash) = split /\|/, $line;

    return {
        pid => $pid,
        port => $port,
        model => $model,
        args_hash => $args_hash,
    };
}

sub process_exists {
    my $pid = shift;
    return kill(0, $pid);
}

sub kill_pid {
    my $pid = shift;
    kill('TERM', $pid);
    sleep 1;
    kill('KILL', $pid) if process_exists($pid);
}

sub kill_instances {
    my ($config, $opts) = @_;

    my $pid_dir = $config->{pid_dir};
    unless (-d $pid_dir) {
        say "${yel}No PID directory found at: $pid_dir$rst";
        say "${gra}(No servers have been started yet)$rst";
        return;
    }

    opendir my $dh, $pid_dir or do {
        say "${red}Can't open PID directory: $!$rst";
        return;
    };
    my @pid_files = grep { /\.pid$/ } readdir($dh);
    closedir $dh;

    unless (@pid_files) {
        say "${yel}No running servers found.$rst";
        return;
    }

    say "${whi}Searching for servers to kill...$rst" if $verbose;

    my $killed_count = 0;
    for my $file (@pid_files) {
        # Skip if port specified and doesn't match (unless --killall)
        if ($opts->{port} && !$opts->{kill_all} && $file ne "port-$$opts{port}.pid") {
            say "${gra}Skipping $file (port mismatch)$rst" if $verbose >= 2;
            next;
        }

        my $full = "$pid_dir/$file";
        my $running = read_pid_file($full);

        unless ($running) {
            say "${gra}Removing malformed PID file: $file$rst" if $verbose >= 2;
            unlink $full;
            next;
        }

        if (process_exists($running->{pid})) {
            my $model_name = basename($running->{model});
            say "${yel}Killing: PID $$running{pid} on port $$running{port} ($model_name)$rst";
            kill_pid($running->{pid});
            unlink $full;
            $killed_count++;
        } else {
            say "${gra}Removing stale PID file: $file (process $$running{pid} not running)$rst" if $verbose;
            unlink $full;
        }

        last unless $opts->{kill_all};
    }

    if ($killed_count == 0) {
        say "${yel}No active servers found to kill.$rst";
    } else {
        say "${gre}Successfully killed $killed_count server(s).$rst";
    }
}

sub show_status {
    my $config = shift;
    my $pid_dir = $config->{pid_dir};

    unless (-d $pid_dir) {
        say "${yel}No PID directory found. No servers running.$rst";
        return;
    }

    opendir my $dh, $pid_dir or do {
        say "${red}Can't open PID directory: $!$rst";
        return;
    };
    my @pid_files = grep { /\.pid$/ } readdir($dh);
    closedir $dh;

    unless (@pid_files) {
        say "${yel}No running servers.$rst";
        return;
    }

    say "${whi}${inv} Running Servers $rst\n";

    my $tb = Text::Table->new(
        { title => "Port", align => 'right' },
        \"  ",
        { title => "PID", align => 'right' },
        \"  ",
        { title => "Model", align => 'left' },
        \"  ",
        { title => "Status", align => 'left' },
    );

    my $active_count = 0;
    for my $file (sort @pid_files) {
        my $full = "$pid_dir/$file";
        my $running = read_pid_file($full);

        unless ($running) {
            next;  # Skip malformed files
        }

        my $model_name = basename($running->{model});
        my $status;

        if (process_exists($running->{pid})) {
            $status = "${gre}RUNNING$rst";
            $active_count++;
        } else {
            $status = "${gra}STALE$rst";
        }

        $tb->add($running->{port}, $running->{pid}, "$cya$model_name$rst", $status);
    }

    print $tb;
    say "\n${gre}Active servers: $active_count$rst";
}

sub update_current_runtime {
    return unless $current_runtime_start;

    # Runtime is now logged in start_server() when server exits
    # This stub remains for signal handlers
    $stats_dirty = 1;
}

sub edit_config {
	system($editor, $config_file);
}

sub list_models {
    my $config = shift;
    
    # Use global $stats if loaded, otherwise load it
    my $stats_to_use = $stats // load_stats($config);

    # Calculate mtime range for normalization
    my ($newest_mtime, $oldest_mtime) = (0, time);
    for my $model (keys %$stats_to_use) {
        my $mtime = $stats_to_use->{$model}{mtime} // 0;
        $newest_mtime = $mtime if $mtime > $newest_mtime;
        $oldest_mtime = $mtime if $mtime < $oldest_mtime && $mtime > 0;
    }

    my @models = sort {
        rank_model($stats_to_use->{$a}, $newest_mtime, $oldest_mtime) <=>
        rank_model($stats_to_use->{$b}, $newest_mtime, $oldest_mtime)
    } keys %$stats_to_use;

    say "${whi}${inv} Models (lowest to highest rank) $rst\n";

	my $tb = Text::Table->new(
		{ title => "Model", align => 'left' },
		{ title => "Rank", align => 'point', align_title => 'center'  },
		{ title => "Uses", align => 'right', align_title => 'right' },
		\"  ",
		{ title => "Loc", align => 'left' },
		{ title => "Last", align => 'left' },
	);
    for my $model (@models) {
        my $mstats = $stats_to_use->{$model};
        my $rank = sprintf("%.1f", rank_model($mstats, $newest_mtime, $oldest_mtime));
        my $uses = $mstats->{total_uses} // 0;
        my $locs = $mstats->{locations} // [];
        my $last = $mstats->{last_used} ? substr($mstats->{last_used}, 0, 10) : 'never';

        # Build location display: SSD (bright cyan) first, then HDD (yellow)
        my @loc_display;
        push @loc_display, "${bcya}SSD${rst}" if grep { $_ eq 'ssd' } @$locs;
        push @loc_display, "${yel}HDD${rst}" if grep { $_ eq 'hdd' } @$locs;
        my $loc_str = @loc_display ? join(' ', @loc_display) : '?';

        # printf "%s%-40s$rst  rank:%6s  uses:%3d  loc:%s%-3s$rst  last:%s\n",
        #     $whi, $model, $rank, $uses, $loc_color, uc($loc), $last;
        $tb->add("$cya$model$rst", $rank, $uses, $loc_str, $last);
    }
    print $tb;
}

# ============================================================================
# SIMULATION FUNCTIONS
# ============================================================================

sub run_simulation {
    my ($config, $opts) = @_;

    my $sim_name = $opts->{simulate};
    my $pattern;
    my $ssd_free_gb;
    my $description;

    # Check if it's a pattern (contains = or ;) or a preset name
    if ($sim_name =~ /[=;]/) {
        # Direct pattern
        $pattern = $sim_name;
        $ssd_free_gb = $opts->{sim_ssd_free} // 100;  # Default 100GB
        $description = "Custom simulation";
    } else {
        # Preset name lookup
        my $sims = $config->{simulations} // {};
        unless ($sims->{$sim_name}) {
            say "${red}Simulation preset '$sim_name' not found in config.$rst";
            say "${yel}Available presets: " . join(', ', sort keys %$sims) . $rst;
            exit 1;
        }

        my $preset = $sims->{$sim_name};
        $pattern = $preset->{pattern};
        $ssd_free_gb = $opts->{sim_ssd_free} // $preset->{ssd_free_gb} // 100;
        $description = $preset->{description} // $sim_name;
    }

    # Parse SSD free space override
    if ($opts->{sim_ssd_free}) {
        $ssd_free_gb = parse_size($opts->{sim_ssd_free}) / (1024**3);
    }

    say "${whi}${inv} Simulation: $sim_name $rst";
    say "${gra}$description$rst\n";

    # Parse the pattern
    my ($model_registry, $timeline) = parse_simulation_pattern($config, $pattern);

    # Display model registry
    say "${whi}Models:$rst";
    for my $name (sort keys %$model_registry) {
        my $m = $model_registry->{$name};
        my $size_str = format_size($m->{size});
        my $source_color = $m->{source} eq 'real' ? $gre : $yel;
        my $source_label = $m->{source} eq 'real' ? "real" : "hypothetical";
        say "  ${cya}$name${rst}: $size_str ($source_color$source_label$rst)";
    }
    say "";

    # Initialize simulation state
    my $sim_state = {
        ssd_free_bytes => $ssd_free_gb * (1024**3),
        ssd_cache => {},  # model_name => {size, rank, stats}
        model_stats => {},  # model_name => {total_uses, use_timestamps, etc}
        actions => [],
    };

    say "${whi}SSD: " . format_size($sim_state->{ssd_free_bytes}) . " free initially$rst\n";
    say "${whi}Timeline:$rst";

    # Process timeline
    for my $event (@$timeline) {
        simulate_event($sim_state, $event, $model_registry, $config);
    }

    # Display final state
    say "\n${whi}${inv} Final State $rst\n";

    if (keys %{$sim_state->{ssd_cache}}) {
        say "${whi}SSD Cache:$rst";
        for my $name (sort { $sim_state->{ssd_cache}{$b}{rank} <=> $sim_state->{ssd_cache}{$a}{rank} }
                      keys %{$sim_state->{ssd_cache}}) {
            my $cached = $sim_state->{ssd_cache}{$name};
            my $size_str = format_size($cached->{size});
            my $rank = sprintf("%.1f", $cached->{rank});
            say "  ${bcya}$name${rst}: $size_str [rank: $rank]";
        }
    } else {
        say "${gra}SSD Cache: (empty)$rst";
    }

    say "\n${whi}SSD Free: " . format_size($sim_state->{ssd_free_bytes}) . $rst;
}

sub parse_simulation_pattern {
    my ($config, $pattern) = @_;

    my %model_registry;
    my @timeline;
    
    # Use global $stats if available, otherwise load
    my $stats_to_use = $stats // load_stats($config);

    # Split by semicolon to get model specs
    my @model_specs = split /\s*;\s*/, $pattern;

    for my $spec (@model_specs) {
        # Parse: modelname:size=time/duration,time/duration,...
        # or:    modelname=time/duration,...

        unless ($spec =~ /^([^=]+)=(.+)$/) {
            die "Invalid simulation spec: $spec\n";
        }

        my ($model_part, $events_part) = ($1, $2);
        my ($model_name, $size_spec);

        # Check if model has size specification
        if ($model_part =~ /^(.+):(\S+)$/) {
            ($model_name, $size_spec) = ($1, $2);
        } else {
            $model_name = $model_part;
        }

        # Register model if not already registered
        unless ($model_registry{$model_name}) {
            if ($size_spec) {
                # Hypothetical model with specified size
                $model_registry{$model_name} = {
                    name => $model_name,
                    size => parse_size($size_spec),
                    source => 'hyp',
                };
            } else {
                # Try to find real model (future: check nicknames first)
                my $model_info = find_model($config, $stats_to_use, $model_name);
                if ($model_info) {
                    $model_registry{$model_name} = {
                        name => $model_name,
                        size => $stats_to_use->{basename($model_info->{path})}{size_bytes} // 0,
                        source => 'real',
                        path => $model_info->{path},
                    };
                } else {
                    die "Model '$model_name' not found. Specify size (e.g., $model_name:45g=...) or use existing model.\n";
                }
            }
        }

        # Parse events: time/duration,time/duration,...
        my @events = split /,/, $events_part;
        my $last_duration;

        for my $event_str (@events) {
            my ($time_str, $duration_str);

            if ($event_str =~ m{^(\S+)/(\S+)$}) {
                # time/duration
                ($time_str, $duration_str) = ($1, $2);
                $last_duration = $duration_str;
            } elsif ($event_str =~ m{^(\S+)$}) {
                # Just time, reuse duration
                $time_str = $1;
                $duration_str = $last_duration;
                die "No duration to reuse at '$event_str' in spec for $model_name\n" unless $last_duration;
            } else {
                die "Invalid event format: $event_str\n";
            }

            my $time_offset = parse_time_offset($time_str);
            my $duration = parse_time_offset($duration_str);

            push @timeline, {
                model => $model_name,
                time => $time_offset,
                duration => $duration,
            };
        }
    }

    # Sort timeline by time
    @timeline = sort { $a->{time} <=> $b->{time} } @timeline;

    return (\%model_registry, \@timeline);
}

sub simulate_event {
    my ($state, $event, $model_registry, $config) = @_;

    my $model_name = $event->{model};
    my $model_info = $model_registry->{$model_name};
    my $time_str = format_time($event->{time});
    my $duration_str = format_time($event->{duration});

    # Initialize model stats if first use
    $state->{model_stats}{$model_name} //= {
        total_uses => 0,
        use_timestamps => [],
        total_runtime_seconds => 0,
    };

    my $mstats = $state->{model_stats}{$model_name};

    # Update stats
    $mstats->{total_uses}++;
    push @{$mstats->{use_timestamps}}, $event->{time};
    $mstats->{total_runtime_seconds} += $event->{duration};
    $mstats->{last_used} = $event->{time};

    # Calculate rank
    my ($newest_mtime, $oldest_mtime) = (time, time - 365*86400);  # Dummy for simulation
    my $rank = rank_model_sim($mstats, $event->{time});

    # Check if should cache to SSD (3+ uses in 7d)
    my $recent_uses = grep { ($event->{time} - $_) < (7 * 86400) } @{$mstats->{use_timestamps}};

    if ($recent_uses >= 3 && !exists $state->{ssd_cache}{$model_name}) {
        say "          ${yel}[TRIGGER]${rst} 3+ uses within 7d → cache to SSD";

        # Check if space available
        if ($model_info->{size} <= $state->{ssd_free_bytes}) {
            $state->{ssd_cache}{$model_name} = {
                size => $model_info->{size},
                rank => $rank,
                stats => $mstats,
            };
            $state->{ssd_free_bytes} -= $model_info->{size};
            say "          ${gre}[COPY→SSD]${rst} ${cya}${model_name}${rst} (" . format_size($model_info->{size}) . ")";
        } else {
            # Need to expire something
            my $needed = $model_info->{size};
            say "          ${yel}[NEED SPACE]${rst} " . format_size($needed) . " required, " . format_size($state->{ssd_free_bytes}) . " available";

            # Find lowest ranked model(s) to expire
            my @cached = sort { $state->{ssd_cache}{$a}{rank} <=> $state->{ssd_cache}{$b}{rank} }
                         keys %{$state->{ssd_cache}};

            while ($state->{ssd_free_bytes} < $needed && @cached) {
                my $to_expire = shift @cached;
                my $expired_size = $state->{ssd_cache}{$to_expire}{size};
                my $expired_rank = $state->{ssd_cache}{$to_expire}{rank};

                delete $state->{ssd_cache}{$to_expire};
                $state->{ssd_free_bytes} += $expired_size;

                say "          ${red}[EXPIRE]${rst} ${gra}${to_expire}${rst} (" . format_size($expired_size) . ", rank: " . sprintf("%.1f", $expired_rank) . ")";
            }

            # Now cache if we have space
            if ($model_info->{size} <= $state->{ssd_free_bytes}) {
                $state->{ssd_cache}{$model_name} = {
                    size => $model_info->{size},
                    rank => $rank,
                    stats => $mstats,
                };
                $state->{ssd_free_bytes} -= $model_info->{size};
                say "          ${gre}[COPY→SSD]${rst} ${cya}${model_name}${rst} (" . format_size($model_info->{size}) . ")";
            } else {
                say "          ${red}[FAILED]${rst} Insufficient space even after expiry";
            }
        }
    } elsif ($recent_uses == 1) {
        say "          ${gra}[INFO]${rst} 1st use within 24h";
    }

    # Update rank in cache if present
    if (exists $state->{ssd_cache}{$model_name}) {
        $state->{ssd_cache}{$model_name}{rank} = $rank;
    }
}

sub rank_model_sim {
    my ($mstats, $current_time) = @_;

    my $total_uses = $mstats->{total_uses} // 0;
    my $last_used = $mstats->{last_used} // $current_time;
    my $seconds_since = $current_time - $last_used;
    my $days_since = $seconds_since / 86400;

    return $total_uses - ($days_since * 2);
}

sub parse_size {
    my $size_str = shift;

    return 0 unless $size_str;

    if ($size_str =~ /^(\d+(?:\.\d+)?)\s*([kmgty])?$/i) {
        my ($num, $unit) = ($1, lc($2 // ''));

        my %multipliers = (
            ''  => 1,
            'k' => 1024,
            'm' => 1024**2,
            'g' => 1024**3,
            't' => 1024**4,
            'y' => 1024**5,
        );

        return int($num * $multipliers{$unit});
    }

    die "Invalid size format: $size_str\n";
}

sub format_size {
    my $bytes = shift;

    return "0B" unless $bytes;

    my @units = ('B', 'KB', 'MB', 'GB', 'TB');
    my $unit_idx = 0;
    my $size = $bytes;

    while ($size >= 1024 && $unit_idx < $#units) {
        $size /= 1024;
        $unit_idx++;
    }

    return sprintf("%.1f%s", $size, $units[$unit_idx]);
}

sub parse_time_offset {
    my $time_str = shift;

    return 0 if $time_str eq '0';

    if ($time_str =~ /^(\d+(?:\.\d+)?)\s*([smhdwmy])?$/i) {
        my ($num, $unit) = ($1, lc($2 // 's'));

        my %multipliers = (
            's' => 1,
            'm' => 60,
            'h' => 3600,
            'd' => 86400,
            'w' => 604800,
            'M' => 2592000,  # 30 days
            'y' => 31536000, # 365 days
        );

        $unit = 'M' if $unit eq 'm' && $time_str =~ /M$/;  # Capital M for month

        return int($num * ($multipliers{$unit} // 1));
    }

    die "Invalid time format: $time_str\n";
}

sub format_time {
    my $seconds = shift;

    return "0s" if $seconds == 0;

    my @parts;

    my $days = int($seconds / 86400);
    $seconds %= 86400;
    push @parts, "${days}d" if $days;

    my $hours = int($seconds / 3600);
    $seconds %= 3600;
    push @parts, "${hours}h" if $hours;

    my $minutes = int($seconds / 60);
    $seconds %= 60;
    push @parts, "${minutes}m" if $minutes;

    push @parts, "${seconds}s" if $seconds || !@parts;

    return join(' ', @parts);
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

sub serr {
    my ($level, @msg) = @_;
    return if $verbose < $level;
    say STDERR a24bg(100, 0, 0) . $whi, @msg, $rst;
}

sub init_colors {
    if (-t STDOUT) {
        ($bgbla, $bgred, $bggre, $bgbro, $bgblu, $bgmag, $bgcya, $bggra) =
            map { "\e[${_}m" } (40..47);
        ($bla, $red, $gre, $bro, $blu, $mag, $cya, $gra) =
            map { "\e[${_}m" } (30..37);
        ($bbla, $bred, $bgre, $yel, $bblu, $bmag, $bcya, $whi) =
            map { "\e[${_}m" } (90..97);
        $rst = "\e[0m";
        $inv = "\e[7m";
    } else {
        ($bgbla, $bgred, $bggre, $bgbro, $bgblu, $bgmag, $bgcya, $bggra) = ('') x 8;
        ($bla, $red, $gre, $bro, $blu, $mag, $cya, $gra) = ('') x 8;
        ($bbla, $bred, $bgre, $yel, $bblu, $bmag, $bcya, $whi) = ('') x 8;
        $rst = $inv = '';
    }
}

sub a24bg {
    my ($r, $g, $b) = @_;
    return '' unless -t STDOUT;
    return "\e[48;2;${r};${g};${b}m";
}

sub a24fg {
    my ($r, $g, $b) = @_;
    return '' unless -t STDOUT;
    return "\e[38;2;${r};${g};${b}m";
}
